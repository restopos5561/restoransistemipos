In Windows PowerShell the command is slightly different “&&” don't use this command. this will use ”;”

Before writing code, do a detailed codebase scan before you start writing code to minimize the risk of making mistakes.

Adhere to the defined client-server architecture, utilizing React/TypeScript for the frontend and Node.js/TypeScript with Express.js for the backend. Utilize the specified technologies for each component (e.g., Redux for frontend state, Prisma for backend ORM).
Follow the established directory structures for both frontend and backend components.
Respect database schema definitions and relationships.
Adhere to the documented API endpoint conventions and data structures.

Utilize existing reusable components in `/src/components` whenever possible.
Ensure all UI components handle loading and error states gracefully.
Define prop names and types clearly (use TypeScript interfaces).
Avoid direct state mutations; use reducers for immutable updates.
Use selectors to access state values.
Dispatch actions consistently with clear naming conventions.
Use middleware like Redux Thunk or Redux Saga for asynchronous operations.
 Handle API errors gracefully within service files (`/src/services`).
Avoid hardcoding API base URLs and sensitive information; use environment variables.
Establish a consistent error handling structure for API calls.
Handle successful and failed API responses correctly, updating state accordingly.

 Validate all form inputs using schema-based validation libraries like Yup with Formik.
Display meaningful validation messages to the user.
 Remember frontend validation is a supplement to backend validation.
 Define explicit and accurate TypeScript types for all components, functions, and variables.
- Avoid using `any`; use `unknown` and perform type checks for safety.
-Define interfaces or types for commonly used structures in `/src/types`.
-Implement routing using `react-router-dom` according to the defined routes in `/src/routes`.
-Retrieve and use route parameters and query parameters correctly.
Centralize authentication and authorization logic
Secure access to sensitive routes with authorization checks.
Use secure and appropriate methods for token management (e.g., HTTP Only cookies in `token.service.ts`).
Keep only routing logic in route files (`/src/routes`). Delegate business logic to controllers.
Define routes according to HTTP methods (GET, POST, PUT, DELETE).
 Controller functions should be short, focused, and perform a single task.
Utilize the service layer (`/src/services`) for database operations and complex business logic.
 Use a consistent structure for handling request parameters, body, and responses.
Service functions should handle database interactions, external API calls, and complex business logic.
 Service functions should be independent of controllers and reusable.
Use Prisma ORM for secure and efficient database interactions.
 Use Prisma models according to the database schema (`/prisma/schema.prisma`).
 Handle database errors correctly (e.g., record not found).
Avoid unnecessary database queries; use relationships efficiently (e.g., `include`).
 Use secure and established libraries for JWT-based authentication.
 Implement role-based authorization logic through middleware (`/src/middleware`).
Never store sensitive data (e.g., passwords) in plain text; use strong hashing algorithms (e.g., bcrypt).
Use middleware for specific tasks (e.g., authentication, authorization, request validation, error handling).
 Apply middleware in the correct order.
Log incoming requests and responses via middleware (for development and debugging).
Validate the body and parameters of incoming requests (using schemas in `/src/schemas`).
Return meaningful error messages for invalid requests.
Establish a consistent error handling mechanism throughout the application.
Catch unexpected errors and return an appropriate (or loggable) response to the user.
Avoid exposing sensitive information in error messages.
 Carefully review the database schema (`/prisma/schema.prisma`) and understand table relationships.
Be aware of changes to the database schema and update your code accordingly.
Use Prisma Migrations when making changes to the database schema.
 Review and apply migration files regularly.
 Use the `seed.ts` file to create sample data for development and testing environments.
 Adhere to established API endpoint patterns (e.g., use plural nouns for resources: `/api/users`, `/api/orders`).
Use consistent HTTP methods (GET, POST, PUT, DELETE) for CRUD operations.
Use the most appropriate HTTP method for each endpoint.
Use consistent JSON structures for API requests and responses.
 Return meaningful HTTP status codes for successful (e.g., 200 OK, 201 Created) and error responses (e.g., 400 Bad Request, 404 Not Found, 500 Internal Server Error).
 Clearly indicate endpoints requiring authentication and ensure valid JWT tokens are sent with requests to these endpoints.
 Avoid direct DOM manipulation (use React's virtual DOM).
 Prevent unnecessary component re-renders (use optimization techniques like `React.memo`, `useCallback`, `useMemo`).
 Clean up event listeners and subscriptions that could cause memory leaks (use the return function of the `useEffect` hook).
 Manage asynchronous operations correctly (use `async/await` or Promises).
 Avoid the N+1 query problem in database queries (use Prisma's eager loading features).
 Avoid writing code that could lead to security vulnerabilities (e.g., SQL injection, XSS).
 Use meaningful and descriptive variable and function names.
 Add sufficient and accurate comments to explain complex logic.
 Use logging to monitor application behavior and debug errors, but avoid logging sensitive information.
Avoid repeating code blocks; make functions and components reusable.
Remove unused code and dependencies.
# React Router Implementation Rules
## Route Configuration
- Always define routes in a centralized location (App.tsx)
- Ensure all route paths are correctly imported and defined
- Double-check route path consistency between navigation and definitions
- Keep route configuration in sync between protected and public routes